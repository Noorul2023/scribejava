package com.github.scribejava.apis.esia;

import com.github.scribejava.apis.EsiaApi;
import com.github.scribejava.core.httpclient.HttpClient;
import com.github.scribejava.core.httpclient.HttpClientConfig;
import com.github.scribejava.core.model.OAuthConstants;
import com.github.scribejava.core.model.OAuthRequest;
import com.github.scribejava.core.oauth.AccessTokenRequestParams;
import com.github.scribejava.core.oauth.OAuth20Service;
import com.github.scribejava.core.utils.Preconditions;

import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class EsiaOAuthService extends OAuth20Service {
  protected static final String TIMESTAMP = "timestamp";
  protected static final String TOKEN_TYPE = "token_type";

  private SigningService signingService;

  public EsiaOAuthService(EsiaApi api, String apiKey, String apiSecret, String callback, String defaultScope,
                          String responseType, OutputStream debugStream, String userAgent,
                          HttpClientConfig httpClientConfig, HttpClient httpClient) {
    super(api, apiKey, null, callback, defaultScope, responseType, debugStream, userAgent, httpClientConfig,
        httpClient);
    if (apiSecret != null) {
      if (isDebug()) {
        log("ESIA API does not use simple apiSecret. " +
                "To sign requests you MUST provide com.github.scribejava.apis.esia.SigningService implementation " +
                "and set it directly to created service using EsiaOAuthService.setSigningService");
      }
    }
  }

  public SigningService getSigningService() {
    return signingService;
  }

  public EsiaOAuthService setSigningService(SigningService signingService) {
    this.signingService = signingService;
    return this;
  }

  @Override
  public void signRequest(String accessToken, OAuthRequest request) {
    throw new RuntimeException("Signing requests has not been implemented in this version");
  }

  @Override
  protected OAuthRequest createAccessTokenRequest(AccessTokenRequestParams params) {
    checkAutoGeneratedParameterNotProvided(params.getExtraParameters(), OAuthConstants.CLIENT_ID);
    checkAutoGeneratedParameterNotProvided(params.getExtraParameters(), TOKEN_TYPE);
    checkAutoGeneratedParameterNotProvided(params.getExtraParameters(), TIMESTAMP);
    checkAutoGeneratedParameterNotProvided(params.getExtraParameters(), OAuthConstants.STATE);
    checkAutoGeneratedParameterNotProvided(params.getExtraParameters(), OAuthConstants.CLIENT_SECRET);

    String scope = params.getScope();
    if (scope == null || scope.isEmpty()) {
      scope = getDefaultScope();
      params.scope(scope);
    }
    final String state = generateState();
    final String timestamp = formatTimestamp(new Date());
    final String clientSecret = generateClientSecret(getApiKey(), scope, timestamp, state);

    return super.createAccessTokenRequest(params
            .addExtraParameter(OAuthConstants.CLIENT_ID, getApiKey())
            .addExtraParameter(TOKEN_TYPE, "Bearer")
            .addExtraParameter(TIMESTAMP, timestamp)
            .addExtraParameter(OAuthConstants.STATE, state)
            .addExtraParameter(OAuthConstants.CLIENT_SECRET, clientSecret)
    );
  }

  @Override
  public String getAuthorizationUrl() {
    return getAuthorizationUrl(getDefaultScope(), null);
  }

  @Override
  public String getAuthorizationUrl(Map<String, String> additionalParams) {
    return getAuthorizationUrl(null, additionalParams);
  }

  public String getAuthorizationUrl(String scope, Map<String, String> additionalParams) {
    if (additionalParams != null) {
      checkAutoGeneratedParameterNotProvided(additionalParams, TIMESTAMP);
      checkAutoGeneratedParameterNotProvided(additionalParams, OAuthConstants.CLIENT_SECRET);
    }
    if (scope == null || scope.isEmpty()) {
      scope = getDefaultScope();
    }
    final String state = generateState();
    final String timestamp = formatTimestamp(new Date());
    final String clientSecret = generateClientSecret(getApiKey(), scope, timestamp, state);

    final Map<String, String> extendedAdditionalParams = new HashMap<>();
    if (additionalParams != null) {
      extendedAdditionalParams.putAll(additionalParams);
    }
    extendedAdditionalParams.put(TIMESTAMP, timestamp);
    extendedAdditionalParams.put(OAuthConstants.CLIENT_SECRET, clientSecret);

    return createAuthorizationUrlBuilder()
        .scope(scope)
        .state(state)
        .additionalParams(extendedAdditionalParams)
        .build();
  }

  protected static void checkAutoGeneratedParameterNotProvided(Map<String, ?> parameters, String key) {
    Preconditions.check(!parameters.containsKey(key), "'" + key + "' parameter is generated automatically");
  }

  protected String generateState() {
    return UUID.randomUUID().toString();
  }

  protected String formatTimestamp(Date date) {
    return new SimpleDateFormat("yyyy.MM.dd HH:mm:ss Z").format(date);
  }

  protected String generateClientSecret(String clientId, String scope, String timestamp, String state) {
    if (signingService == null) {
      throw new IllegalStateException("Cannot generate client_secret parameter. " +
          "Please provide signing service by calling setSigningService");
    }
    final String parametersToSign = scope + timestamp + clientId + state;
    if (isDebug()) {
      log("Signing concatenated authorization request parameters: %s", parametersToSign);
    }
    return signingService.createSignature(parametersToSign);
  }
}
